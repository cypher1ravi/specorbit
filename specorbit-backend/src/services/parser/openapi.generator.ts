import { OpenAPIV3 } from 'openapi-types';
import { ParsedRoute } from './express.parser';

export class OpenApiGenerator {
  
  /**
   * Converts parsed routes into an OpenAPI 3.0 Document
   */
  generateSpec(routes: ParsedRoute[], title: string = 'Generated API', version: string = '1.0.0'): OpenAPIV3.Document {
    
    // 1. Initialize the base spec
    const doc: OpenAPIV3.Document = {
      openapi: '3.0.0',
      info: {
        title,
        version,
        description: 'Auto-generated by SpecOrbit',
      },
      paths: {},
      components: {
        schemas: {}, // We can populate this later
      },
    };

    // 2. Process each route
    for (const route of routes) {
      // Convert Express path to OpenAPI path: /users/:id -> /users/{id}
      const openApiPath = route.path.replace(/:(\w+)/g, '{$1}');

      // Initialize path item if it doesn't exist
      if (!doc.paths[openApiPath]) {
        doc.paths[openApiPath] = {};
      }

      // 3. Build the Operation Object
      const operation: OpenAPIV3.OperationObject = {
        summary: route.description || `Handler for ${route.method} ${route.path}`,
        parameters: route.parameters.map(p => ({
          name: p.name,
          in: p.in,
          required: p.in === 'path' ? true : p.required,
          description: p.description,
          schema: { type: (p.type || 'string') as any } // Use parsed type
        })),
        responses: {}
      };

      // 4. Add Responses
      if (route.responses.length > 0) {
        route.responses.forEach(res => {
          operation.responses![res.status] = {
            description: res.description || 'Response'
          };
        });
      } else {
        // Default 200 OK if none detected
        operation.responses!['200'] = {
          description: 'Successful operation'
        };
      }

      // 5. Attach to the document
      const method = route.method.toLowerCase() as OpenAPIV3.HttpMethods;
      (doc.paths[openApiPath] as any)[method] = operation;
    }

    return doc;
  }
}